---
layout: post
title: Object-Relational Mapping(ORM) - Mapeamento de Objeto-Relacional
date: 2011-04-13 12:00:35.000000000 -03:00
type: post
published: true
status: publish
categories:
- Artigos
tags:
- Banco de Dados
- Getna
- Mapeamento
- Monografia
- ORM
- Relacionamentos
meta:
  _edit_last: '1'
  _efficient_related_posts: 'a:10:{i:0;a:4:{s:2:"ID";s:3:"154";s:10:"post_title";s:49:"GEtna
    - Ep. 3: Mapeando Tabelas do Banco de Dados";s:7:"matches";s:1:"3";s:9:"permalink";s:81:"http://www.redrails.com.br/2008/08/getna-ep-3-mapeando-tabelas-do-banco-de-dados/";}i:1;a:4:{s:2:"ID";s:3:"934";s:10:"post_title";s:20:"Geradores
    de Código";s:7:"matches";s:1:"2";s:9:"permalink";s:53:"http://www.redrails.com.br/2011/04/gerador-de-codigo/";}i:2;a:4:{s:2:"ID";s:3:"580";s:10:"post_title";s:70:"Monografia:
    GEtna  -  Gerador Ruby On Rails a Partir de banco de Dados";s:7:"matches";s:1:"2";s:9:"permalink";s:101:"http://www.redrails.com.br/2009/09/monografia-getna-gerador-ruby-on-rails-a-partir-de-banco-de-dados/";}i:3;a:4:{s:2:"ID";s:3:"145";s:10:"post_title";s:31:"GEtna
    - Ep. 2: Primeiros Passos";s:7:"matches";s:1:"2";s:9:"permalink";s:63:"http://www.redrails.com.br/2008/08/getna-ep-2-primeiros-passos/";}i:4;a:4:{s:2:"ID";s:3:"139";s:10:"post_title";s:23:"GEtna
    - Ep. 1:  A ideia";s:7:"matches";s:1:"2";s:9:"permalink";s:54:"http://www.redrails.com.br/2008/08/getna-ep-1-a-ideia/";}i:5;a:4:{s:2:"ID";s:3:"289";s:10:"post_title";s:28:"GEtna
    0.6.0 (Betha) Liberado";s:7:"matches";s:1:"1";s:9:"permalink";s:60:"http://www.redrails.com.br/2008/11/getna-060-betha-liberado/";}i:6;a:4:{s:2:"ID";s:3:"287";s:10:"post_title";s:20:"GEtna:
    fase de Teste";s:7:"matches";s:1:"1";s:9:"permalink";s:55:"http://www.redrails.com.br/2008/11/getna-fase-de-teste/";}i:7;a:4:{s:2:"ID";s:3:"285";s:10:"post_title";s:23:"GEtna:
    Gerador Funcinal";s:7:"matches";s:1:"1";s:9:"permalink";s:58:"http://www.redrails.com.br/2008/11/getna-gerador-funcinal/";}i:8;a:4:{s:2:"ID";s:3:"228";s:10:"post_title";s:63:"Git:
    Participando de um projeto OpenSource no GitHub - Comandos";s:7:"matches";s:1:"1";s:9:"permalink";s:96:"http://www.redrails.com.br/2008/10/git-participando-de-um-projeto-opensource-no-github-comandos/";}i:9;a:4:{s:2:"ID";s:3:"216";s:10:"post_title";s:36:"Erro
    ao dar Push no repositório GIT";s:7:"matches";s:1:"1";s:9:"permalink";s:71:"http://www.redrails.com.br/2008/10/erro-ao-dar-push-no-repositorio-git/";}}'
  _relation_threshold: '1'
  views: '1'
author:
  login: admin
  email: maximusmano@gmail.com
  display_name: Luiz Carvalho
  first_name: Luiz
  last_name: Carvalho
---
<p><a href="http://www.redrails.com.br/wp-content/uploads/2011/04/tabela001.png"><br />
</a>Mapeamento de Objeto-Relacional (ORM) é uma abordagem que permite a construção de sistemas utilizando o paradigma orientado a objetos com a persistência destes objetos em bancos de dados relacionais. Utilizando-se de técnicas e estratégias específicas, é possível mapear classes com seus atributos e associações para o modelo relacional (SILVA et al.; 2006).<br />
Segundo (AMBLER, 1999), “o mapeamento de classes pode ser feito mediante a paridade entre classe e tabela, ou seja, uma classe é mapeada para uma tabela”. Este mapeamento direto de classes para tabelas representa a forma mais simples de mapeamento, tornando mais fácil o entendimento e a manutenção de uma aplicação. A idéia deste mapeamento pode ser visualizada na Figura 1.</p>
<p><a href="/wp-content/uploads/2011/04/image005.png"><img title="image005" src="{{ site.baseurl }}/assets/posts/image005.png" alt="" width="500" height="139" /></a></p>
<p>Figura 1: Mapeamento de Tabelas - Simples</p>
<p><!--more--></p>
<p>Porém, nem sempre o mapeamento é tão simples assim. No caso de uma estrutura hierárquica, várias classes podem ser mapeadas para uma tabela, bem como uma classe pode ser mapeada para várias tabelas. Esse mapeamento mais complexo de classes e tabelas pode ser observado na Figura 2.</p>
<p><a href="/wp-content/uploads/2011/04/image006.png"><img title="image006" src="{{ site.baseurl }}/assets/posts/image006.png" alt="" width="400" height="281" /></a></p>
<p>Figura 2: Mapeamento            de Tabelas - Complexo</p>
<p>As tabelas Classe1 e Classe2 possuem, respectivamente, relacionamento com as tabelas Tabela1 e Tabela3. Esse mapeamento seria de certa forma trivial, e poderia ser tratado como relacionamento simples. Um terceiro relacionamento feito pelas duas tabelas impossibilita esse tratamento, pois ambas possuem atributos na Tabela2. Dessa forma é necessário que haja uma especificação de quais atributos pertencem a cada classe na Tabela2.</p>
<p>Ao tratar do mapeamento de atributos de uma classe para colunas em tabelas de um banco de dados relacional, deve-se levar em conta que os atributos podem ser de tipos de dados primitivos como inteiros, pontos flutuantes, caracteres, booleanos e binários, bem como ser de tipos de dados complexos como tipos baseados criados pelo usuário. Os atributos podem ser ainda multivalorados, o que viola as regras de normalização do modelo relacional.</p>
<p>Além disso, podem existir atributos de controle ou utilizados em cálculos, que geralmente não necessitam serem mapeados (AMBLER, 1999). Desta forma, os atributos simples podem ser mapeados diretamente para colunas em uma tabela, já os atributos complexos e multivalorados podem necessitar de tabelas adicionais para seu armazenamento. Estes atributos complexos, geralmente, possuem características recursivas, ou seja, são classes que possuem outros atributos e, assim, sucessivamente.<br />
O mapeamento segue o seguinte conceito: as classes mapeiam cada uma das tabelas do banco de dados de modo que as linhas dessas tabelas se tornam objetos e as colunas referem-se aos atributos dessa classe. Esse conceito pode ser visualizado na Figura 3.</p>
<p><a href="/wp-content/uploads/2011/04/image007.png"><img title="image007" src="{{ site.baseurl }}/assets/posts/image007.png" alt="" width="500" height="300" /></a></p>
<p>Figura 3: Mapeamento de Tabelas, Objetos e Atributos</p>
<p>Essa técnica possibilita mais do que códigos limpos, permite que persistências de objetos no banco de dados sejam feitas sem simples e transparente.</p>
<p>O ORM se comporta como uma camada que possui uma gama de métodos que cuidam dessa tarefa, tais como: create (cria um novo objeto da classe a partir dos dados da tabela), find (busca um determinado registro no banco e o torna um objeto da classe), delete (exclui registros do banco) e update (atualiza registros de uma tabela de acordo com as solicitações). Esses métodos variam de acordo com a linguagem utilizada.</p>
<p>Na Tabela 1, é possível observar um pouco das facilidades e de como a legibilidade do código fica melhor ao se utilizar o ORM ao invés de se injetar dentro de seu código o SQL puro, o que fere as boas práticas de programação, que sugere que códigos SQL estejam separados dos códigos de desenvolvimento (RODRIGES; COSTA; SILVEIR, 2001).</p>
<p><a href="/wp-content/uploads/2011/04/tabela001.png"><img title="tabela001" src="{{ site.baseurl }}/assets/posts/tabela001.png" alt="" width="622" height="261" /></a></p>
<p>Essa camada, chamada de persistência, encontra-se entre a camada de negócio (onde estão as classes de domínio da aplicação, ou seja, classes que definem as regras de negócio) e o banco de dados. Esta camada permite que o impacto das modificações em uma delas seja atenuado em relação à outra. Isto diminui o grau de dependência do banco de dados e aumenta a facilidade de manutenção do código. Na Figura 4 pode-se analisar a disposição dessas camadas.</p>
<p><a href="/wp-content/uploads/2011/04/image007.png"><br />
</a></p>
<p><a href="../wp-content/uploads/2011/04/image008.png"><img title="image008" src="{{ site.baseurl }}/assets/posts/image008.png" alt="" width="401" height="263" /></a></p>
<p>Figura 4: Camada de Persistência</p>
<p>Toda responsabilidade por persistir objetos fica a cargo da camada de persistência, liberando a aplicação destas tarefas, e assim aumentando a produtividade no desenvolvimento (YODER; JOHNSON; WILSON,1998). Na camada de persistência está a definição das estratégias de mapeamento do modelo orientado a objetos para o modelo relacional, apresentadas anteriormente.<br />
A camada de classes representa todo o conjunto de classes (controllers, views dentre outras) que podem utilizar métodos da camada de persistência. Assim, as transações com o banco de dados ficam transparentes.<br />
Artigo da série:<br />
<a href="http://www.redrails.com.br/2009/09/monografia-getna-gerador-ruby-on-rails-a-partir-de-banco-de-dados/"><img src="{{ site.baseurl }}/assets/posts/getna_logo_light.png" alt="GETNA" /></a><a href="http://www.redrails.com.br/2009/09/monografia-getna-gerador-ruby-on-rails-a-partir-de-banco-de-dados/"><img src="{{ site.baseurl }}/assets/posts/getna_logo_light_blackpng.png" alt="GETNA" /></a><a href="http://www.redrails.com.br/2009/09/monografia-getna-gerador-ruby-on-rails-a-partir-de-banco-de-dados/"><br />
</a></p>
